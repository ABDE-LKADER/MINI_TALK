# Signals in Unix-like Systems
Signals are a form of inter-process communication (IPC) in Unix-like operating systems, including Linux and macOS. They are used to notify a process that a specific event has occurred. Signals can be sent by the operating system, other processes, or the process itself. They are a way for processes to interrupt each other asynchronously.

## Key Concepts

> **Note:** Signal Types: There are many predefined signals, each identified by a name (e.g., SIGINT, SIGKILL, SIGTERM) and a corresponding integer value.

### Some common signals include:

*  SIGINT (2): Interrupt from the keyboard (usually Ctrl+C).
*  SIGKILL (9): Kill signal (cannot be caught or ignored).
*  SIGTERM (15): Termination signal (can be caught, ignored, or handled).
*  SIGUSR1 and SIGUSR2: User-defined signals.

### Signal Handling: A process can handle signals in three ways:

*  Default Action: The default action for the signal (e.g., terminate the process).
*  Ignore the Signal: The process can ignore the signal.
*  Custom Handler: The process can define a custom function to handle the signal.

## How Signals Work
### Signal Generation: Signals can be generated by various events:

*  Hardware Events: Such as division by zero or illegal memory access.
*  Software Events: Like calling the kill function.
*  User Actions: Pressing Ctrl+C in the terminal.

### Signal Delivery: Once generated, the signal is delivered to the target process. This involves:

*  Kernel Involvement: The kernel plays a crucial role in signal delivery. It maintains a list of pending signals for each process.
*  Process Scheduling: The signal is delivered when the target process is scheduled to run. If the process is already running, it will be interrupted to handle the signal.

## Signal Handling:

*  Check for Handlers: When a process receives a signal, the kernel checks if the process has registered a custom handler for that signal.
*  Invoke Handler: If a custom handler is registered, the kernel invokes the handler function.
*  Default Action: If no custom handler is registered, the kernel performs the signal's default action.

## Sending Signals
Signals can be sent using various system calls:

kill: The kill system call sends a signal to a process or a group of processes.

```
#include <signal.h>
int kill(pid_t pid, int sig);
```

raise: The raise function sends a signal to the calling process.

```
#include <signal.h>
int raise(int sig);
```

sigqueue: The sigqueue function sends a signal with additional data to a process.

```
#include <signal.h>
int sigqueue(pid_t pid, int sig, const union sigval value);
```

# Detailed Example: Sending a Signal

* Server Code (Receiving Process)

```
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

void signal_handler(int signum, siginfo_t *info, void *context) {
    printf("Received signal %d from process %d\n", signum, info->si_pid);
}

int main() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = signal_handler;
    sa.sa_flags = SA_SIGINFO;

    sigaction(SIGUSR1, &sa, NULL);

    printf("Server PID: %d\n", getpid());
    while (1) {
        pause(); // Wait for signals
    }

    return 0;
}
```

* Client Code (Sending Process)

```
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid_t pid = atoi(argv[1]);
    if (kill(pid, SIGUSR1) == -1) {
        perror("Error sending signal");
        exit(EXIT_FAILURE);
    }

    printf("Signal sent to process %d\n", pid);
    return 0;
}
```

# What Happens in the Background

### Sending a Signal:

- Client Process: The client process calls kill(pid, SIGUSR1).
- System Call: The kill function is a system call, so control passes from user space to the kernel.
- Kernel Action: The kernel verifies the target PID and permissions. If valid, it adds the signal to the target process's pending signal list.

### Signal Delivery:

- Process Scheduling: When the target process is scheduled to run, the kernel checks its pending signal list.
- Handler Invocation: If SIGUSR1 is in the list, the kernel invokes the registered handler (signal_handler).
- Handler Execution: The handler executes in the context of the target process, receiving information about the signal and its sender.

### Kernel Mechanisms:

- Signal Masking: The kernel uses a signal mask to block or unblock signals during critical sections.
- Signal Stacks: Signals can be handled on an alternate stack to prevent stack overflow.
- Context Switching: The kernel saves the current execution context, invokes the signal handler, and restores the context afterward.

## Summary
> Signals are a powerful mechanism for IPC in Unix-like systems, allowing processes to communicate asynchronously. Understanding the detailed workings of signal generation, delivery, and handling can help you write robust and responsive applications.
